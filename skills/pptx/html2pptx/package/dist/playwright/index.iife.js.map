{"version":3,"file":"index.iife.js","sources":["../../src/playwright/constants.ts","../../src/playwright/unitConversion.ts","../../src/playwright/textHelpers.ts","../../src/playwright/transformHelpers.ts","../../src/playwright/shadowHelpers.ts","../../src/playwright/inlineFormatting.ts","../../src/playwright/extractSlideDataInBrowser.ts"],"sourcesContent":["/**\n * Constants used in browser-side extraction\n */\n\nexport const PT_PER_PX = 0.75;\nexport const PX_PER_IN = 96;\n\n// Fonts that are single-weight and should not have bold applied\n// (applying bold causes PowerPoint to use faux bold which makes text wider)\nexport const SINGLE_WEIGHT_FONTS = ['impact'];\n","/**\n * Unit conversion utilities for browser-side extraction\n */\n\nimport { PT_PER_PX, PX_PER_IN } from './constants.js';\n\n/**\n * Convert pixels to inches\n */\nexport function pxToInch(px: number): number {\n  return px / PX_PER_IN;\n}\n\n/**\n * Convert pixels to points\n */\nexport function pxToPoints(pxStr: string | number): number {\n  return parseFloat(String(pxStr)) * PT_PER_PX;\n}\n\n/**\n * Convert RGB/RGBA string to hex color\n */\nexport function rgbToHex(rgbStr: string): string {\n  // Handle transparent backgrounds by defaulting to white\n  if (rgbStr === 'rgba(0, 0, 0, 0)' || rgbStr === 'transparent') return 'FFFFFF';\n\n  const match = rgbStr.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);\n  if (!match) return 'FFFFFF';\n  return match\n    .slice(1)\n    .map((n: string) => parseInt(n).toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Extract alpha transparency from RGBA string\n * Returns transparency percentage (0-100) or null if fully opaque\n */\nexport function extractAlpha(rgbStr: string): number | null {\n  const match = rgbStr.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\n  if (!match || !match[4]) return null;\n  const alpha = parseFloat(match[4]);\n  return Math.round((1 - alpha) * 100);\n}\n","/**\n * Text transformation and formatting helpers for browser-side extraction\n */\n\nimport { SINGLE_WEIGHT_FONTS } from './constants.js';\n\n/**\n * Check if a font should skip bold formatting\n * (applying bold causes PowerPoint to use faux bold which makes text wider)\n */\nexport function shouldSkipBold(fontFamily: string): boolean {\n  if (!fontFamily) return false;\n  const normalizedFont = fontFamily.toLowerCase().replace(/['\"]/g, '').split(',')[0].trim();\n  return SINGLE_WEIGHT_FONTS.includes(normalizedFont);\n}\n\n/**\n * Apply CSS text-transform to text\n */\nexport function applyTextTransform(text: string, textTransform: string): string {\n  if (textTransform === 'uppercase') return text.toUpperCase();\n  if (textTransform === 'lowercase') return text.toLowerCase();\n  if (textTransform === 'capitalize') {\n    return text.replace(/\\b\\w/g, (c: string) => c.toUpperCase());\n  }\n  return text;\n}\n","/**\n * CSS transform and positioning helpers for browser-side extraction\n */\n\n/**\n * Extract rotation angle from CSS transform and writing-mode\n */\nexport function getRotation(transform: string, writingMode: string): number | null {\n  let angle = 0;\n\n  // Handle writing-mode first\n  // PowerPoint: 90° = text rotated 90° clockwise (reads top to bottom, letters upright)\n  // PowerPoint: 270° = text rotated 270° clockwise (reads bottom to top, letters upright)\n  if (writingMode === 'vertical-rl') {\n    // vertical-rl alone = text reads top to bottom = 90° in PowerPoint\n    angle = 90;\n  } else if (writingMode === 'vertical-lr') {\n    // vertical-lr alone = text reads bottom to top = 270° in PowerPoint\n    angle = 270;\n  }\n\n  // Then add any transform rotation\n  if (transform && transform !== 'none') {\n    // Try to match rotate() function\n    const rotateMatch = transform.match(/rotate\\((-?\\d+(?:\\.\\d+)?)deg\\)/);\n    if (rotateMatch) {\n      angle += parseFloat(rotateMatch[1]);\n    } else {\n      // Browser may compute as matrix - extract rotation from matrix\n      const matrixMatch = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrixMatch) {\n        const values = matrixMatch[1].split(',').map(parseFloat);\n        // matrix(a, b, c, d, e, f) where rotation = atan2(b, a)\n        const matrixAngle = Math.atan2(values[1], values[0]) * (180 / Math.PI);\n        angle += Math.round(matrixAngle);\n      }\n    }\n  }\n\n  // Normalize to 0-359 range\n  angle = angle % 360;\n  if (angle < 0) angle += 360;\n\n  return angle === 0 ? null : angle;\n}\n\n/**\n * Get position and size accounting for rotation\n */\nexport function getPositionAndSize(\n  el: HTMLElement,\n  rect: DOMRect,\n  rotation: number | null\n): { x: number; y: number; w: number; h: number } {\n  if (rotation === null) {\n    return { x: rect.left, y: rect.top, w: rect.width, h: rect.height };\n  }\n\n  // For 90° or 270° rotations, swap width and height\n  // because PowerPoint applies rotation to the original (unrotated) box\n  const isVertical = rotation === 90 || rotation === 270;\n\n  if (isVertical) {\n    // The browser shows us the rotated dimensions (tall box for vertical text)\n    // But PowerPoint needs the pre-rotation dimensions (wide box that will be rotated)\n    // So we swap: browser's height becomes PPT's width, browser's width becomes PPT's height\n    const centerX = rect.left + rect.width / 2;\n    const centerY = rect.top + rect.height / 2;\n\n    return {\n      x: centerX - rect.height / 2,\n      y: centerY - rect.width / 2,\n      w: rect.height,\n      h: rect.width,\n    };\n  }\n\n  // For other rotations, use element's offset dimensions\n  const centerX = rect.left + rect.width / 2;\n  const centerY = rect.top + rect.height / 2;\n  return {\n    x: centerX - el.offsetWidth / 2,\n    y: centerY - el.offsetHeight / 2,\n    w: el.offsetWidth,\n    h: el.offsetHeight,\n  };\n}\n","/**\n * CSS box-shadow parsing for browser-side extraction\n */\n\nimport { PT_PER_PX } from './constants.js';\nimport { rgbToHex } from './unitConversion.js';\n\n/**\n * Parse CSS box-shadow into PptxGenJS shadow properties\n */\nexport function parseBoxShadow(boxShadow: string): {\n  type: string;\n  angle: number;\n  blur: number;\n  color: string;\n  offset: number;\n  opacity: number;\n} | null {\n  if (!boxShadow || boxShadow === 'none') return null;\n\n  // Browser computed style format: \"rgba(0, 0, 0, 0.3) 2px 2px 8px 0px [inset]\"\n  // CSS format: \"[inset] 2px 2px 8px 0px rgba(0, 0, 0, 0.3)\"\n\n  const insetMatch = boxShadow.match(/inset/);\n\n  // IMPORTANT: PptxGenJS/PowerPoint doesn't properly support inset shadows\n  // Only process outer shadows to avoid file corruption\n  if (insetMatch) return null;\n\n  // Extract color first (rgba or rgb at start)\n  const colorMatch = boxShadow.match(/rgba?\\([^)]+\\)/);\n\n  // Extract numeric values (handles both px and pt units)\n  const parts = boxShadow.match(/([-\\d.]+)(px|pt)/g);\n\n  if (!parts || parts.length < 2) return null;\n\n  const offsetX = parseFloat(parts[0]);\n  const offsetY = parseFloat(parts[1]);\n  const blur = parts.length > 2 ? parseFloat(parts[2]) : 0;\n\n  // Calculate angle from offsets (in degrees, 0 = right, 90 = down)\n  let angle = 0;\n  if (offsetX !== 0 || offsetY !== 0) {\n    angle = Math.atan2(offsetY, offsetX) * (180 / Math.PI);\n    if (angle < 0) angle += 360;\n  }\n\n  // Calculate offset distance (hypotenuse)\n  const offset = Math.sqrt(offsetX * offsetX + offsetY * offsetY) * PT_PER_PX;\n\n  // Extract opacity from rgba\n  let opacity = 0.5;\n  if (colorMatch) {\n    const opacityMatch = colorMatch[0].match(/[\\d.]+\\)$/);\n    if (opacityMatch) {\n      opacity = parseFloat(opacityMatch[0].replace(')', ''));\n    }\n  }\n\n  return {\n    type: 'outer',\n    angle: Math.round(angle),\n    blur: blur * 0.75, // Convert to points\n    color: colorMatch ? rgbToHex(colorMatch[0]) : '000000',\n    offset: offset,\n    opacity,\n  };\n}\n","/**\n * Inline text formatting parser for browser-side extraction\n */\n\nimport type { TextOptions } from '../types.js';\nimport { shouldSkipBold, applyTextTransform } from './textHelpers.js';\nimport { rgbToHex, extractAlpha, pxToPoints } from './unitConversion.js';\n\n/**\n * Text run options for inline formatting\n *\n * Contains style properties that can be applied to individual text runs:\n * - bold: boolean for bold text\n * - italic: boolean for italic text\n * - underline: boolean for underlined text\n * - color: hex color string\n * - transparency: opacity value (0-100)\n * - fontSize: font size in points\n * - bullet: bullet options with indent\n * - breakLine: whether to insert a line break after this run\n *\n * Using Partial<TextOptions> to provide better type safety while\n * allowing flexible text option building.\n */\ntype TextRunOptions = Partial<TextOptions>;\n\n/**\n * Parse inline formatting tags (<b>, <i>, <u>, <strong>, <em>, <span>) into text runs\n */\nexport function parseInlineFormatting(\n  element: HTMLElement,\n  baseOptions: TextRunOptions = {},\n  runs: Array<{ text: string; options: TextRunOptions }> = [],\n  baseTextTransform: (text: string) => string = (x: string) => x,\n  errors: string[] = []\n): Array<{ text: string; options: TextRunOptions }> {\n  let prevNodeIsText = false;\n\n  element.childNodes.forEach((node: ChildNode) => {\n    let textTransform = baseTextTransform;\n\n    const isText = node.nodeType === Node.TEXT_NODE || (node as HTMLElement).tagName === 'BR';\n    if (isText) {\n      const text =\n        (node as HTMLElement).tagName === 'BR'\n          ? '\\n'\n          : textTransform(node.textContent!.replace(/\\s+/g, ' '));\n      const prevRun = runs[runs.length - 1];\n      if (prevNodeIsText && prevRun) {\n        prevRun.text += text;\n      } else {\n        runs.push({ text, options: { ...baseOptions } });\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE && node.textContent!.trim()) {\n      const el = node as HTMLElement;\n      const options = { ...baseOptions };\n      const computed = window.getComputedStyle(el);\n\n      // Handle inline elements with computed styles\n      if (\n        el.tagName === 'SPAN' ||\n        el.tagName === 'B' ||\n        el.tagName === 'STRONG' ||\n        el.tagName === 'I' ||\n        el.tagName === 'EM' ||\n        el.tagName === 'U'\n      ) {\n        const isBold = computed.fontWeight === 'bold' || parseInt(computed.fontWeight) >= 600;\n        if (isBold && !shouldSkipBold(computed.fontFamily)) options.bold = true;\n        if (computed.fontStyle === 'italic') options.italic = true;\n        if (computed.color && computed.color !== 'rgb(0, 0, 0)') {\n          options.color = rgbToHex(computed.color);\n          const transparency = extractAlpha(computed.color);\n          if (transparency !== null) options.transparency = transparency;\n        }\n        if (computed.textDecoration && computed.textDecoration.includes('underline')) {\n          options.underline = {\n            style: 'sng',\n            color: rgbToHex(computed.color),\n          };\n        }\n        if (computed.fontSize) options.fontSize = pxToPoints(computed.fontSize);\n\n        // Apply text-transform on the span element itself\n        if (computed.textTransform && computed.textTransform !== 'none') {\n          const transformStr = computed.textTransform;\n          textTransform = (text: string) => applyTextTransform(text, transformStr);\n        }\n\n        // Validate: Check for margins on inline elements\n        if (computed.marginLeft && parseFloat(computed.marginLeft) > 0) {\n          errors.push(\n            `Inline element <${el.tagName.toLowerCase()}> has margin-left which is not supported in PowerPoint. Remove margin from inline elements.`\n          );\n        }\n        if (computed.marginRight && parseFloat(computed.marginRight) > 0) {\n          errors.push(\n            `Inline element <${el.tagName.toLowerCase()}> has margin-right which is not supported in PowerPoint. Remove margin from inline elements.`\n          );\n        }\n        if (computed.marginTop && parseFloat(computed.marginTop) > 0) {\n          errors.push(\n            `Inline element <${el.tagName.toLowerCase()}> has margin-top which is not supported in PowerPoint. Remove margin from inline elements.`\n          );\n        }\n        if (computed.marginBottom && parseFloat(computed.marginBottom) > 0) {\n          errors.push(\n            `Inline element <${el.tagName.toLowerCase()}> has margin-bottom which is not supported in PowerPoint. Remove margin from inline elements.`\n          );\n        }\n\n        // Recursively process the child node. This will flatten nested spans into multiple runs.\n        parseInlineFormatting(el, options, runs, textTransform, errors);\n      }\n    }\n\n    prevNodeIsText = isText;\n  });\n\n  // Trim leading space from first run and trailing space from last run\n  if (runs.length > 0) {\n    runs[0].text = runs[0].text.replace(/^\\s+/, '');\n    runs[runs.length - 1].text = runs[runs.length - 1].text.replace(/\\s+$/, '');\n  }\n\n  return runs.filter((r) => r.text.length > 0);\n}\n","/**\n * Main extraction logic that runs in the browser context\n * This is the core function that extracts slide data from the DOM\n */\n\nimport type { SlideData, SlideElement, Placeholder, TextRun, ElementStyle } from '../types.js';\nimport {\n  PX_PER_IN,\n  pxToInch,\n  pxToPoints,\n  rgbToHex,\n  extractAlpha,\n  shouldSkipBold,\n  applyTextTransform,\n  getRotation,\n  getPositionAndSize,\n  parseBoxShadow,\n  parseInlineFormatting,\n} from './index.js';\n\nexport type { SlideData };\n\n/**\n * Extract slide data from the current HTML page\n * This function runs in the browser context via page.evaluate()\n */\nexport function extractSlideDataInBrowser(): SlideData {\n  // Extract background from body (image or color)\n  const body = document.body;\n  const bodyStyle = window.getComputedStyle(body);\n  const bgImage = bodyStyle.backgroundImage;\n  const bgColor = bodyStyle.backgroundColor;\n\n  // Collect validation errors\n  const errors: string[] = [];\n\n  // Validate: Check for CSS gradients\n  if (bgImage && (bgImage.includes('linear-gradient') || bgImage.includes('radial-gradient'))) {\n    errors.push(\n      'CSS gradients are not supported. Use Sharp to rasterize gradients as PNG images first, ' +\n        \"then reference with background-image: url('gradient.png')\"\n    );\n  }\n\n  let background: { type: 'image'; path: string } | { type: 'color'; value: string };\n  if (bgImage && bgImage !== 'none') {\n    // Extract URL from url(\"...\") or url(...)\n    const urlMatch = bgImage.match(/url\\([\"']?([^\"')]+)[\"']?\\)/);\n    if (urlMatch) {\n      background = {\n        type: 'image' as const,\n        path: urlMatch[1],\n      };\n    } else {\n      background = {\n        type: 'color' as const,\n        value: rgbToHex(bgColor),\n      };\n    }\n  } else {\n    background = {\n      type: 'color' as const,\n      value: rgbToHex(bgColor),\n    };\n  }\n\n  // Process all elements\n  const elements: SlideElement[] = [];\n  const placeholders: Placeholder[] = [];\n  const textTags = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'OL', 'LI'];\n  const processed = new Set();\n\n  document.querySelectorAll('*').forEach((el) => {\n    if (processed.has(el)) return;\n\n    // Validate text elements don't have backgrounds, borders, or shadows\n    if (textTags.includes(el.tagName)) {\n      const computed = window.getComputedStyle(el);\n      const hasBg = computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)';\n      const hasBorder =\n        (computed.borderWidth && parseFloat(computed.borderWidth) > 0) ||\n        (computed.borderTopWidth && parseFloat(computed.borderTopWidth) > 0) ||\n        (computed.borderRightWidth && parseFloat(computed.borderRightWidth) > 0) ||\n        (computed.borderBottomWidth && parseFloat(computed.borderBottomWidth) > 0) ||\n        (computed.borderLeftWidth && parseFloat(computed.borderLeftWidth) > 0);\n      const hasShadow = computed.boxShadow && computed.boxShadow !== 'none';\n\n      if (hasBg || hasBorder || hasShadow) {\n        errors.push(\n          `Text element <${el.tagName.toLowerCase()}> has ${hasBg ? 'background' : hasBorder ? 'border' : 'shadow'}. ` +\n            'Backgrounds, borders, and shadows are only supported on <div> elements, not text elements.'\n        );\n        return;\n      }\n    }\n\n    // Extract placeholder elements (for charts, etc.)\n    if (el.className && el.className.includes('placeholder')) {\n      const rect = el.getBoundingClientRect();\n      if (rect.width === 0 || rect.height === 0) {\n        errors.push(\n          `Placeholder \"${el.id || 'unnamed'}\" has ${rect.width === 0 ? 'width: 0' : 'height: 0'}. Check the layout CSS.`\n        );\n      } else {\n        placeholders.push({\n          id: el.id || `placeholder-${placeholders.length}`,\n          x: pxToInch(rect.left),\n          y: pxToInch(rect.top),\n          w: pxToInch(rect.width),\n          h: pxToInch(rect.height),\n        });\n      }\n      processed.add(el);\n      return;\n    }\n\n    // Extract images\n    if (el.tagName === 'IMG') {\n      const rect = el.getBoundingClientRect();\n      if (rect.width > 0 && rect.height > 0) {\n        elements.push({\n          type: 'image',\n          src: (el as HTMLImageElement).src,\n          position: {\n            x: pxToInch(rect.left),\n            y: pxToInch(rect.top),\n            w: pxToInch(rect.width),\n            h: pxToInch(rect.height),\n          },\n        });\n        processed.add(el);\n        return;\n      }\n    }\n\n    // Extract DIVs with backgrounds/borders as shapes\n    const isContainer = el.tagName === 'DIV' && !textTags.includes(el.tagName);\n    if (isContainer) {\n      const computed = window.getComputedStyle(el);\n      const hasBg = computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)';\n\n      // Validate: Check for unwrapped text content in DIV\n      for (const node of Array.from(el.childNodes)) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const text = node.textContent?.trim() || '';\n          if (text) {\n            errors.push(\n              `DIV element contains unwrapped text \"${text.substring(0, 50)}${text.length > 50 ? '...' : ''}\". ` +\n                'All text must be wrapped in <p>, <h1>-<h6>, <ul>, or <ol> tags to appear in PowerPoint.'\n            );\n          }\n        }\n      }\n\n      // Check for background images on shapes\n      const bgImage = computed.backgroundImage;\n      if (bgImage && bgImage !== 'none') {\n        errors.push(\n          'Background images on DIV elements are not supported. ' +\n            'Use solid colors or borders for shapes, or use slide.addImage() in PptxGenJS to layer images.'\n        );\n        return;\n      }\n\n      // Check for borders - both uniform and partial\n      const borderTop = computed.borderTopWidth;\n      const borderRight = computed.borderRightWidth;\n      const borderBottom = computed.borderBottomWidth;\n      const borderLeft = computed.borderLeftWidth;\n      const borders = [borderTop, borderRight, borderBottom, borderLeft].map(\n        (b) => parseFloat(b) || 0\n      );\n      const hasBorder = borders.some((b) => b > 0);\n      const hasUniformBorder = hasBorder && borders.every((b) => b === borders[0]);\n      const borderLines: SlideElement[] = [];\n\n      if (hasBorder && !hasUniformBorder) {\n        const rect = el.getBoundingClientRect();\n        const x = pxToInch(rect.left);\n        const y = pxToInch(rect.top);\n        const w = pxToInch(rect.width);\n        const h = pxToInch(rect.height);\n\n        // Collect lines to add after shape (inset by half the line width to center on edge)\n        if (parseFloat(borderTop) > 0) {\n          const widthPt = pxToPoints(borderTop);\n          const inset = widthPt / 72 / 2; // Convert points to inches, then half\n          borderLines.push({\n            type: 'line',\n            x1: x,\n            y1: y + inset,\n            x2: x + w,\n            y2: y + inset,\n            width: widthPt,\n            color: rgbToHex(computed.borderTopColor),\n          });\n        }\n        if (parseFloat(borderRight) > 0) {\n          const widthPt = pxToPoints(borderRight);\n          const inset = widthPt / 72 / 2;\n          borderLines.push({\n            type: 'line',\n            x1: x + w - inset,\n            y1: y,\n            x2: x + w - inset,\n            y2: y + h,\n            width: widthPt,\n            color: rgbToHex(computed.borderRightColor),\n          });\n        }\n        if (parseFloat(borderBottom) > 0) {\n          const widthPt = pxToPoints(borderBottom);\n          const inset = widthPt / 72 / 2;\n          borderLines.push({\n            type: 'line',\n            x1: x,\n            y1: y + h - inset,\n            x2: x + w,\n            y2: y + h - inset,\n            width: widthPt,\n            color: rgbToHex(computed.borderBottomColor),\n          });\n        }\n        if (parseFloat(borderLeft) > 0) {\n          const widthPt = pxToPoints(borderLeft);\n          const inset = widthPt / 72 / 2;\n          borderLines.push({\n            type: 'line',\n            x1: x + inset,\n            y1: y,\n            x2: x + inset,\n            y2: y + h,\n            width: widthPt,\n            color: rgbToHex(computed.borderLeftColor),\n          });\n        }\n      }\n\n      if (hasBg || hasBorder) {\n        const rect = el.getBoundingClientRect();\n        if (rect.width > 0 && rect.height > 0) {\n          const shadowData = parseBoxShadow(computed.boxShadow);\n          const shadow = shadowData ? { ...shadowData, type: 'outer' as const } : null;\n\n          // Only add shape if there's background or uniform border\n          if (hasBg || hasUniformBorder) {\n            elements.push({\n              type: 'shape',\n              text: '', // Shape only - child text elements render on top\n              position: {\n                x: pxToInch(rect.left),\n                y: pxToInch(rect.top),\n                w: pxToInch(rect.width),\n                h: pxToInch(rect.height),\n              },\n              shape: {\n                fill: hasBg ? rgbToHex(computed.backgroundColor) : null,\n                transparency: hasBg ? extractAlpha(computed.backgroundColor) : null,\n                line: hasUniformBorder\n                  ? {\n                      color: rgbToHex(computed.borderColor),\n                      width: pxToPoints(computed.borderWidth),\n                    }\n                  : null,\n                // Convert border-radius to rectRadius (in inches)\n                // % values: 50%+ = circle (1), <50% = percentage of min dimension\n                // pt values: divide by 72 (72pt = 1 inch)\n                // px values: divide by 96 (96px = 1 inch)\n                rectRadius: (() => {\n                  const radius = computed.borderRadius;\n                  const radiusValue = parseFloat(radius);\n                  if (radiusValue === 0) return 0;\n\n                  if (radius.includes('%')) {\n                    if (radiusValue >= 50) return 1;\n                    // Calculate percentage of smaller dimension\n                    const minDim = Math.min(rect.width, rect.height);\n                    return (radiusValue / 100) * pxToInch(minDim);\n                  }\n\n                  if (radius.includes('pt')) return radiusValue / 72;\n                  return radiusValue / PX_PER_IN;\n                })(),\n                shadow: shadow,\n              },\n            });\n          }\n\n          // Add partial border lines\n          elements.push(...borderLines);\n\n          processed.add(el);\n          return;\n        }\n      }\n    }\n\n    // Extract bullet lists as single text block\n    if (el.tagName === 'UL' || el.tagName === 'OL') {\n      const rect = el.getBoundingClientRect();\n      if (rect.width === 0 || rect.height === 0) return;\n\n      const liElements = Array.from(el.querySelectorAll('li'));\n      const items: TextRun[] = [];\n      const ulComputed = window.getComputedStyle(el);\n      const ulPaddingLeftPt = pxToPoints(ulComputed.paddingLeft);\n\n      // Split: margin-left for bullet position, indent for text position\n      // margin-left + indent = ul padding-left\n      const marginLeft = ulPaddingLeftPt * 0.5;\n      const textIndent = ulPaddingLeftPt * 0.5;\n\n      liElements.forEach((li, idx) => {\n        const isLast = idx === liElements.length - 1;\n        const runs = parseInlineFormatting(li, { breakLine: false }, [], (x: string) => x, errors);\n        // Clean manual bullets from first run\n        if (runs.length > 0) {\n          runs[0].text = runs[0].text.replace(/^[•\\-*▪▸]\\s*/, '');\n          runs[0].options.bullet = { indent: textIndent };\n        }\n        // Set breakLine on last run\n        if (runs.length > 0 && !isLast) {\n          runs[runs.length - 1].options.breakLine = true;\n        }\n        items.push(...runs);\n      });\n\n      const computed = window.getComputedStyle(liElements[0] || el);\n\n      elements.push({\n        type: 'list',\n        items: items,\n        position: {\n          x: pxToInch(rect.left),\n          y: pxToInch(rect.top),\n          w: pxToInch(rect.width),\n          h: pxToInch(rect.height),\n        },\n        style: {\n          fontSize: pxToPoints(computed.fontSize),\n          fontFace: computed.fontFamily.split(',')[0].replace(/['\"]/g, '').trim(),\n          color: rgbToHex(computed.color),\n          transparency: extractAlpha(computed.color),\n          align: computed.textAlign === 'start' ? 'left' : computed.textAlign,\n          lineSpacing:\n            computed.lineHeight && computed.lineHeight !== 'normal'\n              ? pxToPoints(computed.lineHeight)\n              : null,\n          paraSpaceBefore: 0,\n          paraSpaceAfter: pxToPoints(computed.marginBottom),\n          // PptxGenJS margin array is [left, right, bottom, top]\n          margin: [marginLeft, 0, 0, 0],\n        },\n      });\n\n      liElements.forEach((li) => processed.add(li));\n      processed.add(el);\n      return;\n    }\n\n    // Extract text elements (P, H1, H2, etc.)\n    if (!textTags.includes(el.tagName)) return;\n\n    const rect = el.getBoundingClientRect();\n    const text = el.textContent!.trim();\n    if (rect.width === 0 || rect.height === 0 || !text) return;\n\n    // Validate: Check for manual bullet symbols in text elements (not in lists)\n    if (el.tagName !== 'LI' && /^[•\\-*▪▸○●◆◇■□]\\s/.test(text.trimStart())) {\n      errors.push(\n        `Text element <${el.tagName.toLowerCase()}> starts with bullet symbol \"${text.substring(0, 20)}...\". ` +\n          'Use <ul> or <ol> lists instead of manual bullet symbols.'\n      );\n      return;\n    }\n\n    const computed = window.getComputedStyle(el);\n    const rotation = getRotation(computed.transform, computed.writingMode);\n    const { x, y, w, h } = getPositionAndSize(el as HTMLElement, rect, rotation);\n\n    const baseStyle: ElementStyle = {\n      fontSize: pxToPoints(computed.fontSize),\n      fontFace: computed.fontFamily.split(',')[0].replace(/['\"]/g, '').trim(),\n      color: rgbToHex(computed.color),\n      align: computed.textAlign === 'start' ? 'left' : computed.textAlign,\n      lineSpacing: pxToPoints(computed.lineHeight),\n      paraSpaceBefore: pxToPoints(computed.marginTop),\n      paraSpaceAfter: pxToPoints(computed.marginBottom),\n      // PptxGenJS margin array is [left, right, bottom, top] (not [top, right, bottom, left] as documented)\n      margin: [\n        pxToPoints(computed.paddingLeft),\n        pxToPoints(computed.paddingRight),\n        pxToPoints(computed.paddingBottom),\n        pxToPoints(computed.paddingTop),\n      ],\n    };\n\n    const transparency = extractAlpha(computed.color);\n    if (transparency !== null) baseStyle.transparency = transparency;\n\n    if (rotation !== null) baseStyle.rotate = rotation;\n\n    const hasFormatting = el.querySelector('b, i, u, strong, em, span, br');\n\n    const elementType = el.tagName.toLowerCase() as 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\n    if (hasFormatting) {\n      // Text with inline formatting\n      const transformStr = computed.textTransform;\n      const runs = parseInlineFormatting(\n        el as HTMLElement,\n        {},\n        [],\n        (str: string) => applyTextTransform(str, transformStr),\n        errors\n      );\n\n      // Adjust lineSpacing based on largest fontSize in runs\n      const adjustedStyle: ElementStyle = { ...baseStyle };\n      if (adjustedStyle.lineSpacing && typeof adjustedStyle.fontSize === 'number') {\n        const maxFontSize = Math.max(\n          adjustedStyle.fontSize,\n          ...runs.map((r) => (typeof r.options?.fontSize === 'number' ? r.options.fontSize : 0))\n        );\n        if (maxFontSize > adjustedStyle.fontSize) {\n          const lineHeightMultiplier =\n            (adjustedStyle.lineSpacing as number) / adjustedStyle.fontSize;\n          adjustedStyle.lineSpacing = maxFontSize * lineHeightMultiplier;\n        }\n      }\n\n      elements.push({\n        type: elementType,\n        text: runs,\n        position: { x: pxToInch(x), y: pxToInch(y), w: pxToInch(w), h: pxToInch(h) },\n        style: adjustedStyle,\n      });\n    } else {\n      // Plain text - inherit CSS formatting\n      const textTransform = computed.textTransform;\n      const transformedText = applyTextTransform(text, textTransform);\n\n      const isBold = computed.fontWeight === 'bold' || parseInt(computed.fontWeight) >= 600;\n\n      elements.push({\n        type: elementType,\n        text: transformedText,\n        position: { x: pxToInch(x), y: pxToInch(y), w: pxToInch(w), h: pxToInch(h) },\n        style: {\n          ...baseStyle,\n          bold: isBold && !shouldSkipBold(computed.fontFamily),\n          italic: computed.fontStyle === 'italic',\n          underline: computed.textDecoration.includes('underline'),\n        },\n      });\n    }\n\n    processed.add(el);\n  });\n\n  return { background, elements, placeholders, errors };\n}\n"],"names":["SINGLE_WEIGHT_FONTS","pxToInch","px","pxToPoints","pxStr","rgbToHex","rgbStr","match","n","extractAlpha","alpha","shouldSkipBold","fontFamily","normalizedFont","applyTextTransform","text","textTransform","c","getRotation","transform","writingMode","angle","rotateMatch","matrixMatch","values","matrixAngle","getPositionAndSize","el","rect","rotation","centerX","centerY","parseBoxShadow","boxShadow","colorMatch","parts","offsetX","offsetY","blur","offset","opacity","opacityMatch","parseInlineFormatting","element","baseOptions","runs","baseTextTransform","x","errors","prevNodeIsText","node","isText","prevRun","options","computed","transparency","transformStr","r","extractSlideDataInBrowser","body","bodyStyle","bgImage","bgColor","background","urlMatch","elements","placeholders","textTags","processed","hasBg","hasBorder","hasShadow","borderTop","borderRight","borderBottom","borderLeft","borders","b","hasUniformBorder","borderLines","y","w","h","widthPt","inset","shadowData","shadow","radius","radiusValue","minDim","liElements","items","ulComputed","ulPaddingLeftPt","marginLeft","textIndent","li","idx","isLast","baseStyle","hasFormatting","elementType","str","adjustedStyle","maxFontSize","lineHeightMultiplier","transformedText","isBold"],"mappings":"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"}